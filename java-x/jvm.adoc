== JVM Features

++++
<table class="toc">
	<tr><td>Launch Source File ⑪</td></tr>
	<tr><td>Multi-Release JARs ⑨</td></tr>
	<tr><td>Redirected Platform Logging ⑨</td></tr>
</table>
++++



== JVM Features

++++
<table class="toc">
	<tr class="toc-current"><td>Launch Source File ⑪</td></tr>
	<tr><td>Multi-Release JARs ⑨</td></tr>
	<tr><td>Redirected Platform Logging ⑨</td></tr>
</table>
++++

Faster feedback with fewer tools.


=== Launching A Single Source File

Compiling and running +
simple Java programs is verbose.

Not any more!

```
java HelloJava11.java
```

=== Background

How it works:

* compiles source into memory
* runs from there

Details:

* requires module _jdk.compiler_ (not in JRE)
* processes options like class/module path et al.
* interprets `@files` for easier option management

=== Use Cases

Mostly similar to `jshell`:

* easier demonstrations
* more portable examples
* experimentation with new language features +
  (combine with `--enable-preview`)

*But also: script files!*

=== Scripts

Steps towards easier scripting:

* arbitrary file names
* shebang support

=== Arbitrary File Names

Use `--source` if file doesn't end in `.java`:

```
java --source 11 hello-java-11
```

=== Shebang Support

To create "proper scripts":

* include shebang in source:
+
```sh
#!/opt/jdk-11/bin/java --source 11
```
* name script and make it executable
* execute it as any other script:
+
```sh
# from current directory:
./hello-java-11
# from PATH:
hello-java-11
```



== JVM Features

++++
<table class="toc">
	<tr><td>Launch Source File ⑪</td></tr>
	<tr class="toc-current"><td>Multi-Release JARs ⑨</td></tr>
	<tr><td>Redirected Platform Logging ⑨</td></tr>
</table>
++++


"Do this on Java X, do that on Java Y."

=== Version Dependence

`Main` calls `Version`:

```java
public class Main {

	public static void main(String[] args) {
		System.out.println(new Version().get());
	}

}
```

=== Version Dependence

`Version` exists twice:

```java
public class Version {

	public String get() { return "Java 8"; }

}

public class Version {

	public String get() { return "Java 9"; }

}
```

(Btw, IDEs hate this!)

=== Creating A Multi&#8209;Release&nbsp;JAR

Now, here's the magic:

* compile `Main` and `Version[8]` to `out/java-8`
* compile `Version[9]` to `out/java-9`
* use new `jar` flag `--release`:
+
```bash
jar --create --file out/mr.jar
	-C out/java-8 .
	--release 9 -C out/java-9 .
```

=== JAR Content

```bash
└ org
    └ codefx ... (moar folders)
        ├ Main.class
        └ Version.class
└ META-INF
    └ versions
        └ 9
            └ org
                └ codefx ... (moar folders)
                    └ Version.class
```

=== Run!

With `java -cp out/mr.jar ...Main`:

* prints `"Java 8"` on Java 8
* prints `"Java 9"` on Java 9

Great Success!



== JVM Features

++++
<table class="toc">
	<tr><td>Launch Source File ⑪</td></tr>
	<tr><td>Multi-Release JARs ⑨</td></tr>
	<tr class="toc-current"><td>Redirected Platform Logging ⑨</td></tr>
</table>
++++


Use your logging framework of choice +
as backend for JDK logging.

=== Loggers and Finders

New logging infrastructure inside the JDK:

* new interface `System.Logger`
* used by JDK classes
* instances created by `System.LoggerFinder`

The interesting bit:

*`LoggerFinder` is a service!*

=== Creating a `Logger`

```java
public class SystemOutLogger implements Logger {

	public String getName() { return "SystemOut"; }

	public boolean isLoggable(Level level) { return true; }

	public void log(
			Level level, ResourceBundle bundle,
			String format, Object... params) {
		System.out.println(/* ...*/);
	}

	// another, similar `log` method

}
```

=== Creating a `LoggerFinder`

```java
public class SystemOutLoggerFinder
		extends LoggerFinder {

	public Logger getLogger(
			String name, Module module) {
		return new SystemOutLogger();
	}

}
```

=== Registering the Service

Module descriptor for _system.out.logger_:

++++
<div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java hljs"><span class="hljs-keyword">module</span> system.out.logger {
    <span class="hljs-keyword">provides</span> java.lang.System.LoggerFinder
        <span class="hljs-keyword">with</span> system.out.logger.SystemOutLoggerFinder;
}</code></pre></div></div>
++++

Module system and JDK take care of the rest!


== A Mixed Bag Of New&nbsp;JVM&nbsp;Features

In Java 9:

* new version strings (http://openjdk.java.net/jeps/223[JEP 223])
* GNU-style command line options (http://openjdk.java.net/jeps/293[JEP 293])
* unified logging (http://openjdk.java.net/jeps/158[JEP 158], http://openjdk.java.net/jeps/271[JEP 271], https://blog.codefx.org/java/unified-logging-with-the-xlog-option/[tutorial])
* command line flag validation (http://openjdk.java.net/jeps/245[JEP 245])
* reserved stack areas (http://openjdk.java.net/jeps/270[JEP 270])
