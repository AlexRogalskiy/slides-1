== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

Some APIs are new, +
many existing ones were improved.



== New or Updated APIs

++++
<table class="toc">
	<tr class="toc-current"><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

Small improvements to `String`.

=== Strip White Space

Getting rid of white space:

```java
String strip();
String stripLeading();
String stripTrailing();
```

Only at beginning and end of string:

```java
" foo bar ".strip().equals("foo bar");
```

=== What About Trim?

Wait, what about `trim()`?

* `trim()` defines white space as:
+
____
any character whose codepoint +
is less than or equal to `'U+0020'` +
(the space character)
____
* `strip()` relies on `Character::isWhitespace`, +
  which covers many more cases

=== Is Blank?

Is a string only white space?

```java
boolean isBlank();
```

Functionally equivalent to:

```java
string.isBlank() == string.strip().isEmpty();
```

=== Life Hack

As soon as Java APIs get new method, +
scour StackOverflow for easy karma!

image::images/so-repeat-string-q.png[role="diagram"]

=== Life Hack

Formerly accepted answer:

image::images/so-repeat-string-a-old.png[role="diagram"]

üòç

=== Life Hack

Ta-da!

image::images/so-repeat-string-a.png[role="diagram"]

=== Streaming Lines

Processing a string's lines:

```java
Stream<String> lines();
```

* splits a string on `"\n"`, `"\r"`, `"\r\n"`
* lines do not include terminator
* more performant than `split("\R")`
* lazy!



== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr class="toc-current"><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

Easy creation of ad-hoc collections.

=== Hope is Pain

Wouldn't this be awesome?

```java
List<String> list = [ "a", "b", "c" ];
Map<String, Integer> map = [ "one" = 1, "two" = 2 ];
```

Not gonna happen!

* language change is costly
* binds language to collection framework
* strongly favors specific collections

=== Next Best Thing

```java
List<String> list = List.of("a", "b", "c");
Map<String, Integer> mapImmediate = Map.of(
		"one", 1,
		"two", 2,
		"three", 3);
Map<String, Integer> mapEntries = Map.ofEntries(
		entry("one", 1),
		entry("two", 2),
		entry("three", 3));
```

[NOTE.speaker]
--
Q: Where does `entry` come from? `Map`
Q: Overloads on `of`? 10
Q: Overloads on `Map::ofEntries`? 1
--

=== Interesting Details

* collections are immutable +
(no immutability in type system, though)
* collections are value-based
* `null` elements/keys/values are forbidden
* iteration order is random between JVM starts +
(except for lists, of course!)



== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr class="toc-current"><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

Small improvements to Java 8 streams.

=== Of Nullable ‚ë®

Create a stream of zero or one elements:

```java
long zero = Stream.ofNullable(null).count();
long one = Stream.ofNullable("42").count();
```

=== Iterate ‚ë®

To use `for` even less...

```java
iterate(
	T seed,
	Predicate<T> hasNext,
	UnaryOperator<T> next);
```

Example:

```java
Stream
	.iterate(1, i -> i<=10, i -> 2*i)
	.forEach(System.out::println);
// output: 1 2 4 8
```

=== Iterate ‚ë®

Counter Example:

```java
Enumeration<Integer> en = // ...
Stream.iterate(
		en.nextElement(),
		el -> en.hasMoreElements(),
		el -> en.nextElement())
	.forEach(System.out::println);
```

* first `nextElement()`
* then `hasMoreElements()`
* ‚áù fail

=== Take While ‚ë®

Stream as long as a condition is true:

```java
Stream<T> takeWhile(Predicate<T> predicate);
```

Example:

```java
Stream.of("a-", "b-", "c-", "", "e-")
	.takeWhile(s -> !s.isEmpty());
	.forEach(System.out::print);

// output: a-b-c-
```

=== Drop While ‚ë®

Ignore as long as a condition is true:

```java
Stream<T> dropWhile(Predicate<T> predicate);
```

Example:

```java
Stream.of("a-", "b-", "c-", "de-", "f-")
	.dropWhile(s -> s.length() <= 2);
	.forEach(System.out::print);

// output: de-f-
```

=== Collect Unmodifiable ‚ë©

Create unmodifiable collections +
(in the sense of `List::of` et al) +
with `Collectors`:

```java
Collector<T, ?, List<T>> toUnmodifiableList();

Collector<T, ?, Set<T>> toUnmodifiableSet();

Collector<T, ?, Map<K,U>> toUnmodifiableMap(
	Function<T, K> keyMapper,
	Function<T, U> valueMapper);
// plus overload with merge function
```



== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr class="toc-current"><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

Small improvements to Java 8 `Optional`.

=== Is Empty ‚ë™

No more `!foo.isPresent()`:

```java
boolean isEmpty()
```

Does exactly what +
you think it does.

=== Or Else Throw ‚ë©

`Optional::get` invites misuse +
by calling it reflexively.

Maybe `get` wasn't the best name? +
New:

```java
T orElseThrow()
```

Works exactly as `get`, +
but more self-documenting.

=== Aligned Names

Name in line with other accessors:

```java
T orElse(T other)
T orElseGet(Supplier<T> supplier)
T orElseThrow()
	throws NoSuchElementException
T orElseThrow(
	Supplier<X> exceptionSupplier)
	throws X
```

=== Get Considered Harmful

https://bugs.openjdk.java.net/browse/JDK-8160606[JDK-8160606]
will deprecate +
`Optional::get`.

* when?
* for removal?

We'll see...

=== Or ‚ë®

Choose a non-empty `Optional`:

```java
Optional<T> or(Supplier<Optional<T>> supplier);
```

=== Find in Many Places

```java
public interface Search {
	Optional<Customer> inMemory(String id);
	Optional<Customer> onDisk(String id);
	Optional<Customer> remotely(String id);

	default Optional<Customer> anywhere(String id) {
		return inMemory(id)
			.or(() -> onDisk(id))
			.or(() -> remotely(id));
	}

}
```

=== If Present Or Else ‚ë®

Like `ifPresent` but do something if empty:

```java
void ifPresentOrElse(
	Consumer<T> action,
	Runnable emptyAction);
```

Example:

```java
void logLogin(String id) {
	findCustomer(id)
		.ifPresentOrElse(
			this::logCustomerLogin,
			() -> logUnknownLogin(id));
}
```

=== Stream ‚ë®

Turns an `Optional` into a `Stream` +
of zero or one elements:

```java
Stream<T> stream();
```

=== Filter-Map ...

```java
private Optional<Customer> findCustomer(String id) {
	// ...
}

Stream<Customer> findCustomers(List<String> ids) {
	return ids.stream()
		.map(this::findCustomer)
		// now we have a Stream<Optional<Customer>>
		.filter(Optional::isPresent)
		.map(Optional::get)
}
```

[transition=none]
=== ... in one Step

```java
private Optional<Customer> findCustomer(String id) {
	// ...
}

Stream<Customer> findCustomers(List<String> ids) {
	return ids.stream()
		.map(this::findCustomer)
		// now we have a Stream<Optional<Customer>>
		// we can now filter-map in one step
		.flatMap(Optional::stream)
}
```

=== From Eager to Lazy

`List<Order> getOrders(Customer c)` is expensive:

```java
List<Order> findOrdersForCustomer(String id) {
	return findCustomer(id)
		.map(this::getOrders) // eager
		.orElse(new ArrayList<>());
}

Stream<Order> findOrdersForCustomer(String id) {
	return findCustomer(id)
		.stream()
		.map(this::getOrders) // lazy
		.flatMap(List::stream);
}
```



== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr class="toc-current"><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

The JDK as common ground +
for reactive stream libraries.

=== Reactive Types

`Publisher`::
* produces items to consume
* can be subscribed to
`Subscriber`::
* subscribes to publisher
* `onNext`, `onError`, `onComplete`
`Subscription`::
* connection between publisher and subscriber
* `request`, `cancel`

=== Reactive Flow
==== Subscribing

* create `Publisher pub` and `Subscriber sub`
* call `pub.subscribe(sub)`
* pub creates `Subscription script` +
and calls `sub.onSubscription(script)`
* `sub` can store `script`

=== Reactive Flow
==== Streaming

* `sub` calls `script.request(10)`
* `pub` calls `sub.onNext(element)` (max 10x)

==== Canceling

* `pub` may call `sub.OnError(err)` +
or `sub.onComplete()`
* `sub` may call `script.cancel()`

=== Reactive APIs?

JDK only provides three interfaces +
and one simple implementation.

(Also called *Flow API*.)

No JDK API uses them. +
(No reactive HTTP connections etc.)



== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr class="toc-current"><td>Stack-Walking ‚ë®</td></tr>
	<tr><td>OS Processes ‚ë®</td></tr>
</table>
++++

Examining the stack faster and easier.

=== `StackWalker::forEach`

```java
void forEach (Consumer<StackFrame>);
```

```java
public static void main(String[] args) { one(); }
static void one() { two(); }
static void two() {
	StackWalker.getInstance()
		.forEach(System.out::println);
}

// output
StackWalkingExample.two(StackWalking.java:14)
StackWalkingExample.one(StackWalking.java:11)
StackWalkingExample.main(StackWalking.java:10)
```

=== `StackWalker::walk`

```java
T walk (Function<Stream<StackFrame>, T>);
```

```java
static void three() {
	String line = StackWalker.getInstance().walk(
		frames -> frames
			.filter(f -> f.getMethodName().contains("one"))
			.findFirst()
			.map(f -> "Line " + f.getLineNumber())
			.orElse("Unknown line");
	);
	System.out.println(line);
}

// output
Line 11
```

=== Options

`getInstance` takes options as arguments:

* `SHOW_REFLECT_FRAMES` for reflection frames
* `SHOW_HIDDEN_FRAMES` e.g. for lambda frames
* `RETAIN_CLASS_REFERENCE` for `Class<?>`

=== Frames and Traces

`forEach` and `walk` operate on `StackFrame`:

* class and method name
* class as `Class<?>`
* bytecode index and isNative

Can upgrade to `StackTraceElement` (expensive):

* file name and line number

=== Performance I

image::images/stack-walker-vs-exception.png[role="diagram"]

=== Performance II

image::images/stack-walker-limit-with-estimated-size.png[role="diagram"]

=== Performance III

* creating `StackTraceElement` is expensive +
(for file name and line number)
* lazy evaluation pays off for partial traversal

(Benchmarks performed by https://twitter.com/arnaudroger[Arnaud Roger])



== New or Updated APIs

++++
<table class="toc">
	<tr><td>String Improvements ‚ë™</td></tr>
	<tr><td>Collection Factories ‚ë®</td></tr>
	<tr><td>Stream Improvements ‚ë®‚ë©</td></tr>
	<tr><td>Optional Improvements ‚ë®‚ë©‚ë™</td></tr>
	<tr><td>Reactive Streams ‚ë®</td></tr>
	<tr><td>Stack-Walking ‚ë®</td></tr>
	<tr class="toc-current"><td>OS Processes ‚ë®</td></tr>
</table>
++++

Improving interaction with OS processes.

=== Simple Example

```shell
ls /home/nipa/tmp | grep pdf
```

```java
Path dir = Paths.get("/home/nipa/tmp");
ProcessBuilder ls = new ProcessBuilder()
		.command("ls")
		.directory(dir.toFile());
ProcessBuilder grepPdf = new ProcessBuilder()
		.command("grep", "pdf")
		.redirectOutput(Redirect.INHERIT);
List<Process> lsThenGrep = ProcessBuilder
		.startPipeline(List.of(ls, grepPdf));
```

=== Extended `Process`

Cool new methods on `Process`:

* `boolean supportsNormalTermination();`
* `long pid();`
* `CompletableFuture<Process> onExit();`
* `Stream<ProcessHandle> children();`
* `Stream<ProcessHandle> descendants();`
* `ProcessHandle toHandle();`

=== New `ProcessHandle`

New functionality actually comes from `ProcessHandle`.

Interesting `static` methods:

* `Stream<ProcessHandle> allProcesses();`
* `Optional<ProcessHandle> of(long pid);`
* `ProcessHandle current();`

=== More Information

`ProcessHandle` can return `Info`:

* command, arguments
* start time
* CPU time



== A Mixed Bag Of API&nbsp;Changes

In Java 9:

* multi-resolution images (http://openjdk.java.net/jeps/251[JEP 251])
* native desktop integration (http://openjdk.java.net/jeps/272[JEP 272])
* deserialization filter (http://openjdk.java.net/jeps/290[JEP 290])
* HTTP/2 (http://openjdk.java.net/jeps/110[JEP 110]), DTLS (http://openjdk.java.net/jeps/219[JEP 219]), +
TLS ALPN and OCSP stapling (http://openjdk.java.net/jeps/244[JEP 244])
* OASIS XML Catalogs 1.1 (http://openjdk.java.net/jeps/268[JEP 268]), +
Xerces 2.11.0 (http://openjdk.java.net/jeps/255[JEP 255])
// TODO does this include Xerxes support for XSLT 2?

Many lower-level APIs.

////
* Unicode support via `PropertyResourceBundle` (http://openjdk.java.net/jeps/226[JEP 226])
* Unicode 8.0 support (http://openjdk.java.net/jeps/227[JEP 227], http://openjdk.java.net/jeps/267[JEP 267])
////
