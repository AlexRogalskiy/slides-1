= Expert Java 8
:backend: revealjs
:revealjs_theme: nipa-night
:revealjsdir: ../_reveal.js
:revealjs_controls: false
:revealjs_progress: false
:revealjs_slideNumber: false
:revealjs_history: true
:revealjs_center: true
:revealjs_transition: slide
:revealjs_backgroundTransition: fade
:revealjs_parallaxBackgroundImage: images/8-dark.jpg
:revealjs_parallaxBackgroundSize: 2560px 1440px

[[TODO, check why imagedir does not work]]
:imagedir: images

include::../_shared/highlight.js.adoc[]

++++
<style>
.reveal .title h2 {
	font-size: 1.75em;
}
</style>
<h2>Lambdas, Optionals, Streams<br>For Those Who Know<br>What They Are Doing</h2>
++++

:host-name: Jfokus
:host-url: https://www.jfokus.se/jfokus/
:host-logo-url: images/logo-jfokus.png
:host-twitter-name: #jfokus
:host-twitter-url: https://twitter.com/hashtag/JFokus?src=hash
include::../_shared/event-on-title-and-footer.adoc[]




== Optional

++++
<table class="toc">
	<tr><td>Value-Based Class</td></tr>
	<tr><td>Not a Monad</td></tr>
</table>
++++

* intention
** http://blog.codefx.org/java/dev/design-optional/
* pragmatic vs strict approach
** http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html
** http://blog.codefx.org/java/stream-performance/
* performance
* `Optional` is not a Monad (and why it matters)


== Optional Is A Value-Based&nbsp;Class

[[TODO, use non-breaking dash]]
++++
<table class="toc">
	<tr class="toc-current"><td>Value-Based Class</td></tr>
	<tr><td>Not a Monad</td></tr>
</table>
++++

`Optional` implements a new "pattern" +
that requires us to be careful with what we do

=== Value-Based Class?

Did you RTFM?

https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html[`Optional` Javadoc] says:

> This is a value-based class; use of identity-sensitive operations [...] on instances of `Optional` may have unpredictable results and should be avoided.

What does it mean?

=== Value Types In Future Java

Future Java (10?) will contain value types:

* pass by value +
(copied when passed as params)
* immutable
* no identity

Very similar to today's primitives.

=== No Identity?

Class instances *have identity*:

* each `new Integer(5)` creates a new instance
* they are not identical (`!=`, different locks, ...)

Value types will have *no identity*:

* there are no two different `int 5`
* only their value matters

=== But Isn't This Java 8?

From value types to value-based classes:

* value types require wrappers/boxes +
(just like primitives do today)
* as an optimization the JVM will +
create and destroy them at will

*‚áù Wrappers have identity _but_ it is unstable*

Guess which classes will become wrappers?

[NOTE.speaker]
--
* vbc will be optimized in Java 10!
--

=== Requirements For VBC

* final and immutable
* factory methods instead of constructors +
(and no guarantees regarding instances!)
* `equals`, `hashCode`, `toString` +
must only rely on instance state (not identity)
* must be fully interchangeable when `equal`
* no use of `==`, identity hash code, +
locking, serialization

(None of this is checked by the JVM.)

=== VBC in Java 8

`java.util`::
	`Optional`[`Double`, `Long`, `Int`]
`java.time`::
	`Duration`, `Instant`, `Period`, +
	`Year`, `YearMonth`, `MonthDay`, +
	`Local...`, `Offset...`, `Zoned...`
`java.time.chrono`::
	`HijrahDate`, `JapaneseDate`, `MinguaDate`, `ThaiBuddhistDate`

[NOTE.speaker]
--
* Optional uses reference `equals` in its `equals`
* date classes are serializable
--

=== VBC Reflection

With `Optional` and other value-based classes:

* never rely on their identity
* mainly no `==`, locking, serialization

More details:

http://blog.codefx.org/java/value-based-classes/[blog.codefx.org/java/value-based-classes/]

[NOTE.speaker]
--
* can reference mutable objects
--


== Optional Is Not A Monad

++++
<table class="toc">
	<tr><td>Value-Based Class</td></tr>
	<tr class="toc-current"><td>Not a Monad</td></tr>
</table>
++++

`Optional` saves us from `null` +
at the expense of breaking Monad Laws

(No math, I promise!)

=== Left Identity

For a Monad, this should always be true:

```java
Objects.equals(
	ofNullable(x).flatMap(f),
	f.apply(x));
```

But:

```java
Function f = s -> of("mango")
Optional ofMap =
	ofNullable(null).flatMap(f);
Optional apply = f.apply(null);
// Optional[] != Optional["mango"]
```

=== Associativity

For a Monad, this should always be true:

```java
Objects.equals(
	ofNullable(x).map(f).map(g),
	ofNullable(x).map(f.andThen(g)));
```

But:

```java
Function f = s -> null;
Function g = s -> "mango";
Optional map = of("kiwi").map(f).map(g);
Optional then = of("kiwi").map(f.andThen(g));
// Optional[] != Optional["mango"]
```

=== Root Cause Analysis

* `Optional` maps `null` to `empty()`
* `flatMap` and `map` are not executed +
on empty optionals
* the first occurrence of `null`/empty +
stops the chain of executions

=== So What?

* refactoring by merging functions +
or breaking them apart +
can lead to different execution paths
* functions that can "recover" from `null` +
will not get executed
* particularly error-prone +
when functions have side effects +
(they generally should not but it happens)

=== Monad Reflection

* be aware that `Optional` is no well-behaved monad
* see it as a way to avoid handling `null`
* be aware that refactoring can cause problems +
if `null` was special cased


== Stream

* sources
** https://www.youtube.com/watch?v=sbcXQJA0EQc
** https://www.youtube.com/watch?v=oWlWEKNM5Aw
** http://blog.codefx.org/java/rebutting-5-common-stream-tropes/
** http://blog.codefx.org/java/stream-performance/
** http://blog.codefx.org/java/stream-findfirst-findany-reduce/

* content
** overarching goal: more readable code by using simple building blocks (fuck succinctness)
** utility methods to start streams
** method handles > lambdas & short lambdas > long lambdas
** abstraction
*** higher level than when writing loops
      "see first part of https://www.youtube.com/watch?v=iDplU7mOocU"
** error handling
** look at reduce more often
** findFirst, findAny vs findOnly
** utility methods for complicated collectors
** performance model
    "second part of https://www.youtube.com/watch?v=iDplU7mOocU"
*** overheads
*** parallelization
** missing features
    https://medium.com/@johnmcclean/java-8-streams-10-missing-features-ec82ee90b6c0#.5fffwftma
* returning Streams
* performance


== Default Methods

* anything interesting in here?
** http://blog.codefx.org/java/everything-about-default-methods/

=== Interface Evolution

* http://blog.codefx.org/design/patterns/interface-evolution-with-default-methods-methods/

=== Isolate From Library

Use FP library of your choice to get functional interfaces that can throw exceptions.
Maybe wrap'em:

```java
public interface CoolLibFunction<T, S> {

	S call(T arg);

}

public interface MyFunction<T, S> extends CoolLibFunction<T, S> {

	@Deprecated
	default S call(T arg) {
		return execute(args);
	}

	S execute(T arg);

}
```

This way it is very unlikely to accidentally rely on `CoolLibFunction::call`
 and it can be exchanged for another lib without breaking your code.


== Lambda APIs

* Instances of non-capt. Lambdas
** http://blog.codefx.org/java/instances-non-capturing-lambdas/

Instead of relying on setup and teardown to be executed by calling the right methods at the right time, write a method that does both and executes some code in between.

E.g. instead of:

```java
Weld weld = new Weld();
WeldContainer container = weld.initialize();
TextApplication textApplication = container.instance().select(TextApplication.class).get();
textApplication.run();
weld.shutdown();
```

Do this:

```java
private static void main(Sring[] args) {
	withInitializedWeld(container -> {
		TextApplication textApplication = container.instance().select(TextApplication.class).get();
		textApplication.run();
	})
}

private static void withInitializedWeld(Consumer<WeldContainer> with) {
	Weld weld = new Weld();
	WeldContainer container = weld.initialize();
	with.accept(container);
	weld.shutdown();
}
```

Other ideas:

* https://arnaudroger.github.io/blog/2016/09/19/consumer-in-place-of-returning-list.html
* query-then-act idioms can be implemented in a single method if the "act" part is a lambda, compare `Map::computeIfAbsent`
* functional implementations of interfaces
** http://blog.codefx.org/techniques/getting-rid-of-anonymous-classes/

== Patterns

* http://www.javamagazine.mozaicreader.com/NovDec2016#&pageSet=55&page=0&contentItem=0
* my post about decorator


== Ideas

* Concurrency changes: http://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/changes8.html
* Trisha Gee refactoring to Java 8 https://www.youtube.com/watch?v=NcetKbGayZY
* documentation with new tags
** http://blog.codefx.org/java/new-javadoc-tags/







// ######### //
// O U T R O //
// ######### //

== Questions?

include::../_shared/about-slide.adoc[]

== Image Credits

* bubbles:
https://www.flickr.com/photos/elwillo/[Keith Williamson]
(https://creativecommons.org/licenses/by/2.0/[CC-BY 2.0])
* question-mark:
http://milosevicmilos.com/[Milos Milosevic]
(https://creativecommons.org/licenses/by/2.0/[CC-BY 2.0])
