= Expert Java 8
:backend: revealjs
:revealjs_theme: nipa-night
:revealjsdir: ../_reveal.js
:revealjs_controls: false
:revealjs_progress: false
:revealjs_slideNumber: false
:revealjs_history: true
:revealjs_center: true
:revealjs_transition: slide
:revealjs_backgroundTransition: fade
:revealjs_parallaxBackgroundImage: images/8-dark.jpg
:revealjs_parallaxBackgroundSize: 2560px 1440px

[[TODO, check why imagedir does not work]]
:imagedir: images

include::../_shared/highlight.js.adoc[]

++++
<style>
.reveal .title h2 {
	font-size: 1.75em;
}
</style>
<h2>Lambdas, Optionals, Streams<br>For Those Who Know<br>What They Are Doing</h2>
++++

:host-name: Jfokus
:host-url: https://www.jfokus.se/jfokus/
:host-logo-url: images/logo-jfokus.png
:host-twitter-name: #jfokus
:host-twitter-url: https://twitter.com/hashtag/JFokus?src=hash
include::../_shared/event-on-title-and-footer.adoc[]


// ############### //
// O P T I O N A L //
// ############### //

== Optional

[[TODO, explore performance]]

++++
<h3>Everybody's Favorite Bike Shed!</h3>
<table class="toc">
	<tr><td>Usage Patterns</td></tr>
	<tr><td>Value-Based Class</td></tr>
	<tr><td>Not a Monad</td></tr>
</table>
++++


== Optional

++++
<table class="toc">
	<tr class="toc-current"><td>Usage Patterns</td></tr>
	<tr><td>Value-Based Class</td></tr>
	<tr><td>Not a Monad</td></tr>
</table>
++++

The Java community strongly disagrees +
on how to best use `Optional`.

Some insights into the discussion...

=== Basic Rules

[[TODO, silly hat background]]

First some basic rules:

* never, ever, ever just call `get` +
without checking `isPresent` first
* prefer functional style +
(`map`, `flatMap`, `ifPresent`, `orElse`, ...)
* make everyone setting `Optional` to `null` +
buy a round of drinks or wear a silly hat

=== Basic Rules

Nobody (?) wants to see ...

```java
Optional.ofNullable(mango)
	.ifPresent(System.out::println);
```

\... instead of ...

```java
if (mango != null)
	System.out.println(mango);
```

=== Different Opinions

* don't use it unless +
absolutely necessary
* use it as return value
* use it everywhere

=== Don't Use It!
==== Assumptions

* API is verbose and invites misuse
* not serializable
* unsupported by various frameworks +
(JSON, ORM)
* dereferencing reduces performance
* instances increase memory consumption
* no benefits over explicit `null` handling

=== Don't Use It!
==== Conclusions

* `Optional` sucks
* only use it if existing API returns it
* unpack quickly!

[[TODO, check names and arguments; make smaller]]
(Mark Struberg, Stephen Conolly)


=== Return Value Only
==== Assumptions

* http://blog.codefx.org/java/dev/design-optional[was designed] as a return value
* not serializable
* long-lived instances increase +
memory consumption
* boxing method arguments is verbose

=== Return Value Only
==== Conclusions

* use freely as return value
* no instance variables
* no method parameters
* instances should generally be short-lived

[[TODO, check names; make smaller]]
(Stuart Marks, Brian Goetz,  Stephen Colebourne)

*⇝ This should be your default choice!*

=== Use Everywhere!
==== Assumptions

* using `Optional` instead of `null` +
lifts `null`-handling into the type system
* makes any remaining `null` +
an implementation error +
(great for debugging)
* performance arguments can be discarded +
(unless proven to be relevant)

=== Use Everywhere!
==== Conclusions

* avoid optionality through good design +
(good recommendation in general)
* use `Optional` instead of `null` everywhere
* consider providing overloads +
for optional method parameters

[[TODO, make smaller]]
(Mario Fusco, me)

=== Use Everywhere!
==== Overload Example

```java
String bar(Optional<String> drink) {
	return drink.map(this::bar)
			.orElseGet(this::bar);
}

String bar(String drink) { /* ... */ }

String bar() { /* ... */ }
```

=== Reflection on Usage

Whatever you decide:

* pick my recommendation! :)
* make it a team decision
* put it into your code style
* learn over time

Relaxing rules is easier +
than making them stricter!

=== Additional Sources

http://blog.codefx.org/java/dev/design-optional[Design Of Optional] (codefx.org)

http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html[Pragmatic Approach]  (joda.org)

http://blog.codefx.org/java/stephen-colebourne-optional-a-strict-approach/[Strict Approach]  (codefx.org)

[[TODO, look up and add name to slide]]
http://huguesjohnson.com/programming/java/java8optional.html[TODO] (huguesjohnson.com)

== Optional

++++
<table class="toc">
	<tr><td>Usage Patterns</td></tr>
	<tr class="toc-current"><td>Value-Based Class</td></tr>
	<tr><td>Not a Monad</td></tr>
</table>
++++

`Optional` implements a new "pattern" +
that requires us to be careful with what we do.

=== Value-Based Class?

Did you RTFM?

https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html[`Optional` Javadoc] says:

> This is a value-based class; use of identity-sensitive operations [...] on instances of `Optional` may have unpredictable results and should be avoided.

What does it mean?

=== Value Types In Future Java

Future Java (10?) will contain value types:

* pass by value +
(copied when passed as params)
* immutable
* no identity

Very similar to today's primitives.

=== No Identity?

Class instances *have identity*:

* each `new Integer(5)` creates a new instance
* they are not identical (`!=`, different locks, ...)

Value types will have *no identity*:

* there are no two different `int 5`
* only their value matters

=== But Isn't This Java 8?

From value types to value-based classes:

* value types require wrappers/boxes +
(just like primitives do today)
* value-based classes might turn out +
wrapping value types
* as an optimization the JVM will +
create and destroy them at will

*⇝ Wrappers have identity _but_ it is unstable*

[NOTE.speaker]
--
* vbc will be optimized in Java 10!
--

=== Identity Crisis

```java
Map<User, LocalDateTime> userLogins;
Map<LocalDateTime, String> messages;

String lastLoginMessage(User user) {
	LocalDateTime lastLogin =
		userLogins.get(user); // <1>
	String message = "Was " + lastLogin;
	messages.put(lastLogin, message); // <2>
	return message;
}
```
<1> `get` might return an instance or a value
<2> `put` might receive an instance or a value


=== Requirements For VBC

declaration site::
* final and immutable
* `equals`, `hashCode`, `toString` +
must _only_ rely on instance state
* ...
use site::
* no use of `==`, identity hash code, +
locking, serialization

(None of this is checked by the JVM.)

=== VBC in Java 8

`java.util`::
	`Optional`[`Double`, `Long`, `Int`]
`java.time`::
	`Duration`, `Instant`, `Period`, +
	`Year`, `YearMonth`, `MonthDay`, +
	`Local...`, `Offset...`, `Zoned...`
`java.time.chrono`::
	`HijrahDate`, `JapaneseDate`, `MinguaDate`, `ThaiBuddhistDate`

[NOTE.speaker]
--
* Optional uses reference `equals` in its `equals`
* date classes are serializable
--

=== VBC Reflection

With `Optional` and other value-based classes:

* never rely on their identity
* mainly no `==`, locking, serialization

*If this works out,* +
*performance hit all but disappears!*

==== Additional Sources

http://blog.codefx.org/java/value-based-classes/[Value-Based Classes] (codefx.org)

[NOTE.speaker]
--
* can reference mutable objects
--


== Optional

++++
<table class="toc">
	<tr><td>Usage Patterns</td></tr>
	<tr><td>Value-Based Class</td></tr>
	<tr class="toc-current"><td>Not a Monad</td></tr>
</table>
++++

`Optional` saves us from `null` +
at the expense of breaking Monad Laws.

(No math, I promise!)

=== Left Identity

For a Monad, this should always be true:

```java
Objects.equals(
	ofNullable(x).flatMap(f),
	f.apply(x));
```

But:

```java
Function f = s -> of("mango")
Optional ofMap =
	ofNullable(null).flatMap(f);
Optional apply = f.apply(null);
// Optional[] != Optional["mango"]
```

=== Associativity

For a Monad, this should always be true:

```java
Objects.equals(
	ofNullable(x).map(f).map(g),
	ofNullable(x).map(f.andThen(g)));
```

But:

```java
Function f = s -> null;
Function g = s -> "mango";
Optional map = of("kiwi").map(f).map(g);
Optional then = of("kiwi").map(f.andThen(g));
// Optional[] != Optional["mango"]
```

=== Root Cause Analysis

* `Optional` maps `null` to `empty()`
* `flatMap` and `map` are not executed +
on empty optionals
* the first occurrence of `null`/empty +
stops the chain of executions

=== So What?

* refactoring can change +
which code gets executed
* functions that can "recover" from `null` +
might not get executed
* particularly error-prone when +
functions have side effects +
(they generally should not but it happens)

=== Monad Reflection

* be aware that `Optional` is no well-behaved monad
* see it as a way to avoid handling `null`
* be aware that refactoring can cause problems +
if `null` was special cased

==== Additional Sources

https://developer.atlassian.com/blog/2015/08/optional-broken/[More on Optional Being Broken] (atlassian.com)

https://www.sitepoint.com/how-optional-breaks-the-monad-laws-and-why-it-matters/[... and Why It Matters] (sitepoint.com)

== Stream

* sources
** https://www.youtube.com/watch?v=sbcXQJA0EQc
** https://www.youtube.com/watch?v=oWlWEKNM5Aw
** http://blog.codefx.org/java/rebutting-5-common-stream-tropes/
** http://blog.codefx.org/java/stream-performance/
** http://blog.codefx.org/java/stream-findfirst-findany-reduce/

* content
** overarching goal: more readable code by using simple building blocks (fuck succinctness)
** utility methods to start streams
** method handles > lambdas & short lambdas > long lambdas
** abstraction
*** higher level than when writing loops
      "see first part of https://www.youtube.com/watch?v=iDplU7mOocU"
** error handling
** look at reduce more often
** findFirst, findAny vs findOnly
** utility methods for complicated collectors
** performance model
    "second part of https://www.youtube.com/watch?v=iDplU7mOocU"
*** overheads
*** parallelization
** missing features
    https://medium.com/@johnmcclean/java-8-streams-10-missing-features-ec82ee90b6c0#.5fffwftma
* returning Streams
* performance


== Default Methods

* anything interesting in here?
** http://blog.codefx.org/java/everything-about-default-methods/

=== Interface Evolution

* http://blog.codefx.org/design/patterns/interface-evolution-with-default-methods-methods/

=== Isolate From Library

Use FP library of your choice to get functional interfaces that can throw exceptions.
Maybe wrap'em:

```java
public interface CoolLibFunction<T, S> {

	S call(T arg);

}

public interface MyFunction<T, S> extends CoolLibFunction<T, S> {

	@Deprecated
	default S call(T arg) {
		return execute(args);
	}

	S execute(T arg);

}
```

This way it is very unlikely to accidentally rely on `CoolLibFunction::call`
 and it can be exchanged for another lib without breaking your code.


== Lambda APIs

* Instances of non-capt. Lambdas
** http://blog.codefx.org/java/instances-non-capturing-lambdas/

Instead of relying on setup and teardown to be executed by calling the right methods at the right time, write a method that does both and executes some code in between.

E.g. instead of:

```java
Weld weld = new Weld();
WeldContainer container = weld.initialize();
TextApplication textApplication = container.instance().select(TextApplication.class).get();
textApplication.run();
weld.shutdown();
```

Do this:

```java
private static void main(Sring[] args) {
	withInitializedWeld(container -> {
		TextApplication textApplication = container.instance().select(TextApplication.class).get();
		textApplication.run();
	})
}

private static void withInitializedWeld(Consumer<WeldContainer> with) {
	Weld weld = new Weld();
	WeldContainer container = weld.initialize();
	with.accept(container);
	weld.shutdown();
}
```

Other ideas:

* https://arnaudroger.github.io/blog/2016/09/19/consumer-in-place-of-returning-list.html
* query-then-act idioms can be implemented in a single method if the "act" part is a lambda, compare `Map::computeIfAbsent`
* functional implementations of interfaces
** http://blog.codefx.org/techniques/getting-rid-of-anonymous-classes/

== Patterns

* http://www.javamagazine.mozaicreader.com/NovDec2016#&pageSet=55&page=0&contentItem=0
* my post about decorator


== Ideas

* Concurrency changes: http://docs.oracle.com/javase/8/docs/technotes/guides/concurrency/changes8.html
* Trisha Gee refactoring to Java 8 https://www.youtube.com/watch?v=NcetKbGayZY
* documentation with new tags
** http://blog.codefx.org/java/new-javadoc-tags/







// ######### //
// O U T R O //
// ######### //

== Questions?

include::../_shared/about-slide.adoc[]

== Image Credits

* bubbles:
https://www.flickr.com/photos/elwillo/[Keith Williamson]
(https://creativecommons.org/licenses/by/2.0/[CC-BY 2.0])
* question-mark:
http://milosevicmilos.com/[Milos Milosevic]
(https://creativecommons.org/licenses/by/2.0/[CC-BY 2.0])
