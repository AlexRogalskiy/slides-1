////
* sources
** https://www.youtube.com/watch?v=sbcXQJA0EQc
** https://www.youtube.com/watch?v=oWlWEKNM5Aw
** http://blog.codefx.org/java/rebutting-5-common-stream-tropes/
** http://blog.codefx.org/java/stream-performance/
** http://blog.codefx.org/java/stream-findfirst-findany-reduce/

* content
** overarching goal: more readable code by using simple building blocks (fuck succinctness)
** utility methods to start streams
** method handles > lambdas & short lambdas > long lambdas
** abstraction
*** higher level than when writing loops
      "see first part of https://www.youtube.com/watch?v=iDplU7mOocU"
** error handling
** look at reduce more often
** utility methods for complicated collectors
** performance model
    "second part of https://www.youtube.com/watch?v=iDplU7mOocU"
*** overheads
*** parallelization
** missing features
    https://medium.com/@johnmcclean/java-8-streams-10-missing-features-ec82ee90b6c0#.5fffwftma
* performance
////

== Streams


== Streams

// toc

Using streams in your APIs.

=== Interesting Stream Properties

* streams are unmodifiable
* streams are easy to transform
* streams are lazy

⇝ Good way to enrich data in layers.

=== Enrichment Example

```java
Map<String, User> userById;
Map<String, Address> addrById;

Stream<User> users() {
	return userById.values().stream();
}

Stream<UserAddress> userAddresses() {
	return users().map(user -> {
		Address addr = addrById.get(user.id());
		return UserAddress.of(user, addr);
	});
}
```

=== Enrichment Example

```java
Map<Address, List<Order>> ordersByAddr;

Stream<Delivery> orders() {
	return userAddresses().flatMap(userAddr ->
		ordersByAddr
			.get(userAddr.address()).stream()
			.map(order -> Delivery
				.of(userAddr, order)));
}
```

=== Guidelines

* streams can only be traversed once +
⇝ ideally new streams can be recreated endlessly
* during traversal collection must not be mutated +
⇝ stick to layers instead of cycles +
(can be harder than it sounds)
* decide careful where to call `parallel()`

=== Accepting Streams

Returning streams is ok.

What about passing them as parameters?

* streams can only be traversed once!
* caller must assume stream is traversed
* works for obvious consumer functions
* possibly a transformed stream can be returned

=== Stream Param Example

```java
// consuming the passed stream
void addUsers(Stream<User> users) {
	// ...
}

// transforming the passed stream
Stream<UserAddress> userAddresses(
		Stream<User> users) {
	return users.map(user -> {
		Address addr = addrById.get(user.id());
		return UserAddress.of(user, address);
	});
}
```

=== Guidelines

* consumers are straight-forward
* transformations can be hard to track
* never return a traversed stream +
(obvious, right?!)

=== Reflection On APIs

*Returning streams:*

* returning streams is great +
(unmodifiable but transformable)
* preferably if streams can be recreated
* can be used to gradually enrich data

*Passing streams:*

* works for obvious consumers
* caller must assume stream is traversed

=== Reflection On APIs

*But look out:*

* streams can only be traversed once
* no mutation during traversal
* don't make chains too long or +
debuggability suffers


== Streams

// toc

Be careful how you find!

=== Finding First or Any

`Stream::findFirst` and `findAny`:

* return an arbitrary element from the Stream
* if stream has encounter order, +
`findFirst` returns first element

Often used after a filter.

=== Find Example

```java
Optional<User> findUser(String id) {
	return users.stream()
		.filter(user -> user.getId().equals(id))
		.findFirst();
}
```

Same as the loop:

```java
Optional<User> findUser(String id) {
	for (User user : users)
		if (user.getId().equals(id))
			return Optional.of(user);
	return Optional.empty();
}
```

=== Small Observation

I often saw the following:

* code's correctness depends on only +
one element passing the filter
* *but* there are no additional checks

*⇝ The easy solution might be the wrong one!*

[role="small-note"]
(All of this applies to the loop as well.)

=== Finding Only

Make sure there is only one element:

```java
Optional<User> findUser(String id) {
	return users.stream()
		.filter(user -> user.getId().equals(id))
		.reduce(toOnlyElement());
}

static BinaryOperator toOnlyElement() {
	return (element, otherElement) -> {
		throw new IllegalArgumentException();
	};
}
```

Instead of `reduce`, `collect` could be used.

=== Properties of Finding Only

Upsides:

* guarantees correctness by failing fast
* expresses intent

Downsides:

* materializes entire stream

=== Reflection On Finding

If correctness depends on only one element +
surviving an ad-hoc filter:

* `findFirst`, `findAny` do not suffice
* use a reducer or collector to assert uniqueness
* comes with a performance penalty

==== Additional Sources

http://blog.codefx.org/java/stream-findfirst-findany-reduce/[Beware Of findFirst() And findAny()]
