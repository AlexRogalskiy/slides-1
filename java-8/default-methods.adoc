== Default Methods

++++
<table class="toc">
	<tr><td>Lambda Expressions</td></tr>
	<tr><td>Stream API</td></tr>
	<tr><td>Optional API</td></tr>
	<tr class="toc-current"><td>Default Methods</td></tr>
</table>
++++

=== Mmh...

Where does `Collection::stream` come from?

* new method on a public interface
* breaks all third-party implementations

=== Collection::stream

Take a look at `Collection` interface:

```java
default Stream<E> stream() {
	return StreamSupport.stream(spliterator(), false);
}
```

* what's `default`?
* why is there a method body?

== Default Methods

++++
<table class="toc">
	<tr class="toc-current"><td>Syntax &amp; Semantics</td></tr>
	<tr><td>Existing Functionality</td></tr>
	<tr><td>Kinds of Default Methods</td></tr>
	<tr><td>Fluent Decorators</td></tr>
	<tr><td>Interface Evolution</td></tr>
	<tr><td>Summary</td></tr>
</table>
++++

=== Intention

* add methods to interfaces +
without breaking implementations
* extend existing interfaces +
to improve usability
* easy programing model

=== Default Method Syntax

```java
// in `List`
default void sort(Comparator<? super E> c) {
	// do the sorting
}
```

* keyword `default`
* regular method signature and body
* automatically `public` (as usual)

=== Resolution Strategy

Rule #1::
Classes win over interfaces.
Rule #2::
More specific interfaces win over less specific ones.
Rule #3::
There's no Rule #3.

=== Implications of Rule #1

(_Classes win over interfaces_)

* it is not possible to have default implementation +
of methods on `Object` (e.g. `equals`/`hashCode`)
* it is possible to "reabstract" methods:
+
```java
abstract class MyCollection<E>
		implements Collection<E> {

	public abstract Stream<E> stream();

}
```

=== Implications of Rule #2

(_More specific interfaces win over less specific ones._)

An interface extending another can provide +
a more suitable default implementation.

=== Example for Rule #2

```java
// in `Map`
default V getOrDefault(Object key, V defaultValue) {
	V v;
	return (((v = get(key)) != null) || containsKey(key))
		? v
		: defaultValue;
}

// in `ConcurrentMap`
default V getOrDefault(Object key, V defaultValue) {
	V v;
	return ((v = get(key)) != null) ? v : defaultValue;
}
```

=== Implications of Rule #3

(_There's no Rule #3_)

Occasional compile errors +
that have to be fixed manually.

Two choices:

* you can properly implement the method
* you can call a specific default method:
+
```java
public void collidingMethod() {
	ImplementedInterface.super
		.collidingMethod();
}
```

=== Exercise 1

Adding default methods and +
observing resolution strategy.

=== Static Interface Methods

Interfaces can now also have static methods. +
(*These are not "static default" methods!*)

Syntax as usual:

```java
public static <T> Comparator<T> nullsLast(
		Comparator<? super T> comparator) {
	return new Comparators
		.NullComparator<>(false, comparator);
}
```

=== Static Interface Methods

Use cases:

* factory methods for implementations +
(e.g. `List::of`; if you can bare it)
* utility methods for an interface +
(e.g. `Predicate::not`)

=== Private Interface Methods

Interfaces can now also have private methods. â‘¨ +
(*These are not "private default" methods!*)

Syntax as usual:

```java
private String concat(String... args);
	// ...
}
```

=== Private Interface Methods

Use case:

Reusing code in default methods.


== Existing Functionality

++++
<table class="toc">
	<tr><td>Syntax &amp; Semantics</td></tr>
	<tr class="toc-current"><td>Existing Functionality</td></tr>
	<tr><td>Kinds of Default Methods</td></tr>
	<tr><td>Fluent Decorators</td></tr>
	<tr><td>Interface Evolution</td></tr>
	<tr><td>Summary</td></tr>
</table>
++++

=== Existing Functionality

Many functional interfaces have +
usability default methods:

* Collections
* `Comparator`
* functional interfaces

=== Collections

* `Iterable.forEach(Consumer<T>)`
* `Collection.removeIf(Predicate<E>)`
* `Collection.stream()`
* `List.replaceAll(UnaryOperator<E>)`
* `List.sort(Comparator<E>)`

Many more on various collections.

=== Comparator

```java
Comparator<Todo> comparator = Comparator
	.comparing(todo -> todo.due());
comparator = comparator.reversed();
comparator = Comparator.nullsLast(comparator);
```

(Many more.)

=== Functional Interfaces

* `Function.andThen(Function<R, V>)`
* `Function.identity()`
* `Predicate.and(Predicate<T>)`
* `Predicate.negate()`


== Kinds of Default Methods

++++
<table class="toc">
	<tr><td>Syntax &amp; Semantics</td></tr>
	<tr><td>Existing Functionality</td></tr>
	<tr class="toc-current"><td>Kinds of Default Methods</td></tr>
	<tr><td>Fluent Decorators</td></tr>
	<tr><td>Interface Evolution</td></tr>
	<tr><td>Summary</td></tr>
</table>
++++

=== Three Kinds

Default methods come in three flavors:

* "optional" methods
* "reasonable" implementations
* "definitive" implementations

=== "Optional" methods

Barely useful implementation:

```java
// in Iterator
default void remove() {
	throw new UnsupportedOperationException("remove");
}
```

* fulfill (weak) contract
* look for them when +
implementing interface

=== "Reasonable" Implementation

Useful implementation:

```java
// in Iterator
default void forEach(Consumer<? super E> consumer) {
	while (hasNext())
		consumer.accept(next());
}
```

* safe to use
* might be overridden for better implementation

=== "Definitive" Implementation

Sometimes, there isn't really +
any other possible implementation:

```java
default Predicate<T> and(Predicate<? super T> p) {
	Objects.requireNonNull(p);
	return (T t) -> test(t) && p.test(t);
}
```


== Default Methods

++++
<table class="toc">
	<tr><td>Syntax &amp; Semantics</td></tr>
	<tr><td>Existing Functionality</td></tr>
	<tr><td>Kinds of Default Methods</td></tr>
	<tr class="toc-current"><td>Fluent Decorators</td></tr>
	<tr><td>Interface Evolution</td></tr>
	<tr><td>Summary</td></tr>
</table>
++++

=== Decorator Pattern

image::images/decorator.png[role="diagram"]

```java
Component component = /*...*/;
Component decorated =
	new SomeDecorator(
		new AnotherDecorator(component));
```

=== Fluent Decorators

With lambda expressions and default methods +
we can apply decorators fluently:

```java
Component component = /*...*/;
Component decorated = DecoratingComponent.from(component)
	.some() // applies `SomeDecorator`
	.another("param") // applies `AnotherDecorator`
	.decorate(YetAnotherDecorator::new);
```

How?

=== Fluent Decorators

image::images/decorator-8.png[role="diagram"]

The `DecoratingComponent` interface:

* extends `Component`
* is implemented by all decorators
* offers methods that wrap `this` +
  in decorator and return it

=== Decorating Component

```java
interface DecoratingC extends Component {

	static DecoratingC from(Component component) {
		return new DecoratingComponent() {
			// implement by forwarding to component
		};
	}

	default DecoratingC decorate(
		Function<DecoratingC, DecoratingC> decorator) {
		return decorator.apply(this);
	}

}
```

=== Generic Decoration

This _generic decoration_ +
allows chains like the following:

```java
Component component = /*...*/;
Component decorated = DecoratingComponent.from(component)
	.decorate(SomeDecorator::new);
	.decorate(c -> new AnotherDecorator(c, "param"));
	.decorate(YetAnotherDecorator::new);
```

=== Specific Decoration

```java
interface DecoratingC extends Component {

	default DecoratingC some()
		return decorate(SomeDecorator::new);
	}

	default DecoratingC another(String s)
		return decorate(
			c -> new AnotherDecorator(c, s));
	}

}
```

=== Fluent Decoration

Real-life example:

```java
HyperlinkListener listener =
	this::changeHtmlViewBackgroundColor;
listener = DecoratingHyperlinkListener.from(listener)
	.onHoverMakeVisible(urlLabel)
	.onHoverSetUrlOn(urlLabel)
	.logEvents()
	.decorate(l ->
		new OnActivateHighlightComponent(l, urlLabel))
	.decorate(OnEnterLogUrl::new);
```

=== Why Default Methods?

Why not put these methods on `AbstractDecorator`?

* clumps up responsibilities:
+
====
** enabling easy implementation of `Component`
** decorating instances of `Component`
====
+
(change for different reasons)
* requires implementation of abstract helper class
* makes abstract helper class prominent

=== Exercise 2

Implement a fluent decorator API.


== Default Methods

++++
<table class="toc">
	<tr><td>Syntax &amp; Semantics</td></tr>
	<tr><td>Existing Functionality</td></tr>
	<tr><td>Kinds of Default Methods</td></tr>
	<tr><td>Fluent Decorators</td></tr>
	<tr class="toc-current"><td>Interface Evolution</td></tr>
	<tr><td>Summary</td></tr>
</table>
++++

=== Interface Evolution

If your code has clients that +
you have no control over...

* open-source library
* internal library
* extensible application

\... then evolving interfaces +
always breaks code.

Default methods to the rescue!

=== General Approach

New Version::

* interface is transitional (old and new outline)
* default methods ensure existing code works

Transition::

* client moves from old to new outline
* default methods ensure code keeps working

New Version::

* removes old outline

=== Adding Methods

Reasonable default impl exists:

New Version::

* add the method with default impl
* internal impls can override
* internal callers use new method

Transition::

* external callers use the method

That's it.

=== Adding Methods

No reasonable default impl exists:

New Version::

* add method with default impl throwing UOE
* override method in all internal impls

Transition::

* external impls override the method
* external callers use the method

New Version::

* make method abstract
* internal callers use new method

=== Removing Methods

No external impls exist:

New Version::

* deprecate method
* internal callers stop calling method

Transition::

* external callers stop using the method

New Version::

* remove the method

(No default methods required.)

=== Removing Methods

External impls exist:

New Version::

* deprecate method
* provide default impl throwing UOE
* internal callers stop calling method

Transition::

* external callers stop using the method
* external impls of the method are removed

New Version::

* remove the method

=== Replacing Methods

Applies with new signature (name, parameters, ...), +
where methods are "functionally equivalent".

Otherwise it's a matter of adding new +
and removing old method.

=== Replacing Methods

New Version::

* add _new_ with default impl calling _old_
* provide default impl of _old_ calling _new_
* deprecate _old_
* internal impls override _new_ instead of _old_
* internal callers use _new_ instead of _old_

Wtf, circular call?

* ensures it does not matter which version is impl'd
* must be thoroughly documented; tests help

=== Replacing Methods

Transition::

* external impls override _new_ instead of _old_
* external callers use _new_ instead of _old_

New Version::

* make _new_ abstract
* remove _old_

=== Evolution Summary

If clients can be expected to update their code +
default methods allow interface evolution +
without breaking client code.

Mode is always the same:

* release version with transitional outline
* give clients time to update
* release version with new outline


== Summary

++++
<table class="toc">
	<tr><td>Syntax &amp; Semantics</td></tr>
	<tr><td>Existing Functionality</td></tr>
	<tr><td>Kinds of Default Methods</td></tr>
	<tr><td>Interface Evolution</td></tr>
	<tr class="toc-current"><td>Summary</td></tr>
</table>
++++

=== Summary

Syntax & Semantics:

* interfaces can have instance methods:
** add `default` keyword
** implement as usually
* method resolution:
** methods from classes are _always_ preferred
** default methods are "fall back"
* interface can have static and private +
methods just like classes

=== Summary

Many existing and new interfaces +
have default methods.

Specific use cases:

* create fluent decorator APIs
* evolve interfaces without breaking clients
